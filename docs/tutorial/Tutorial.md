# Setup and Installation

## Pre-reqs (Estimated time to complete : 10-15 minutes)
You can do one of the following things to get the pre-reqs installed
- [Install the needed packages on your Linux ubuntu machine or OS X machine](LocalInstall.md)
- If you don't want to install the needed packages or you are on a windows machines [download an existing VirtualBox image](VirtualBoxAppliance.md) with everything installed and configured 
- If you don't want to download the 1 gig existing VM image, you can [create and configure a VM on your own](CreateVmFromScratch.md) 
 
# Part 1

Please see the architecture document [here](../arch/README.md) before continuing.  Once you have read the overview, please checkout the branch `tutorial_part_1`.

## Overview

The code in this branch will be a minimum skeleton to demonstrate how PSS_Qualifying works.  The skeleton has implemented one feature : allowing users to get information about a specific `Event`. This tutorial use the skeleton to introduce you to the PSS_Qualifying code structure and how it works.

## A quick demo
Before we start the tutorial, let's try using the skeleton to get information about an event.  We do this by running the following command at the top level of the PSS_Qualifying repo : 
```
PYTHONPATH=. gunicorn -b 0.0.0.0:8000 'test_app:app' -w $1 --reload
```  
You have now started the PSS_Qualifying server.  At the moment it is not neccessary for you to understand what the gunicorn command does or what the arguments to it are - but if you want to learn more you can look at the comments in `app/__init__.py` and `test_app/__init__.py` 
 
In order to use the PSS_Qualifying server to get the info for an existing event in the database, hit the url `http://0.0.0.0:8000/event/1` (in a seperate shell with `curl` or through your webbrowser) and you will get a result that looks like : 
```
{
  event_id:1,
  event_name:"test"
}
```

The rest of this document covers how information is stored in the database, how that information is accessed by the PSS_Qualifying code, and how that information gets requested by (and returned to) users.    


## Directory structure of PSS_Qualifying

- app : The code that initializes and configures the Flask object lives here.
- ignore : a directory that will be ignored by git ( good for putting secret info into ).
- lib : Code that is shared across PSS_Qualifying goes here.
- models : The SQLalchemy models live here.
- proxies : The code that is responsible for accessing the database lives here.
- routes : The code that implements the business logic as Flask routes lives here.
- tests : Unit and integration tests live here.
- utils : Scripts that are needed for bootstrapping, starting the PSS_Qualifying server, and dumping info from the databases live here.

## Event model

PSS_Qualifying uses SQLalchemy to query and/or modify data in the database.  SQLalchemy models are classes that represent tables in a database and the relationships between those tables (i.e. one-to-one, one-to-many, many-to-many).  A single `Event` (i.e. papa 20) is represented by the `Events` model in `models/Events.py`

```
def generate_event_model(db):
    class Events(db.Model):
        event_id = db.Column(db.Integer, primary_key=True)
        event_name = db.Column(db.String(80), unique=True, nullable=False)
        
        def __repr__(self):
            return '<Event %r>' % self.event_name
    return Events
```

The name of the model class is the name used for the table in the database - this is why it is named `Events` instead of `Event` because we want the table to have the plural name.  The `Events` model has two fields - the `event_id` (which gets auto-generated by the database) and the `event_name` which is the name of the event (i.e. PAPA 20).  The `generate_event_model()` function has to be called with a `SQLalchemy` object (A SQLalchemy object represents a connection to a database - `db` in the code above is a `SQLalchemy` object) to actually declare the `Events` class.  We'll discuss later (in the `Event Route` section) where the `SQLalchemy` object gets declared and why the `Events` class is generated, but for now you just need to know that all model classes need to be generated in the same way.  In the meantime, let's see what actually calls `generate_event_model()`.

## TableProxy and EventsProxy

The `TableProxy` class in `proxies/TableProxy.py` is a class that is used to call the database access code.  Let's look at the `__init__()` function :

```
    def __init__(self, sqlAlchemyHandle, app):
        self.sqlAlchemyHandle = sqlAlchemyHandle
        self.events_proxy = EventsProxy(self.sqlAlchemyHandle)
```

It takes a `SQLalchemy` object as an argument (the `sqlAlchemyHandle` is expected to be a `SQLalchemy` object) - we'll discuss later what is responsbile for creating an instance of the `TableProxy` ( in the `Event Route` section ).  The `TableProxy` creates an instance of the `EventsProxy` class in it's `__init__()` function.  The `EventsProxy` contains all the code related to initializing a `Events` model and accessing the `Events` table in the database using the `Events` model.  Each table in the database will have it's own Proxy class.  Let's take a look at the `EventsProxy` class in `proxies/EventsProxy.py`, and let's start with the `__init__()` function :

```
    def __init__(self,
                 sqlAlchemyHandle,
                 event_model=None):
        self.sqlAlchemyHandle = sqlAlchemyHandle
        self.event_model=generate_event_model(self.sqlAlchemyHandle) if event_model is None else event_model
```

The `__init__()` function will call `generate_event_model()`.  It also allows you to pass in a model which is used for testing purposes.  Now let's look at the `get_event()` function : 
```
    def get_event(self,event_id,serialized=True):
        event = self.event_model.query.filter_by(event_id=event_id).first()
        if serialized:
            if event is None:
                return None,None            
            dict_to_return = to_dict(event)            
            return event,dict_to_return
        else:
            return event 
```

There are two things to notice here : 
- Serialization happens at the EventProxy level, not at the business logic level
- The function allows for choosing whether or not to return a serialized version of the event retrieved.  The reason for this is because this function could be called from other EventProxy functions and from business logic code.  We don't want to waste time serializing if another EventProxy function is calling `get_event()`.  But if it is being called by business logic code we always want to return a serialized version of the event found, because this serialized version is what will eventually make it to the user. 

## Event route


